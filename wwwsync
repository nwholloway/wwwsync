#! /usr/bin/perl
# WWWSync: Upload new modifications to your WWW pages by ftp.
# Author : Nick Holloway 
#  Email : Nick.Holloway@alfie.demon.co.uk
#    WWW : http://www.alfie.demon.co.uk/

$RCSid = '$Id: wwwsync,v 1.2 1996/08/08 11:06:20 alfie Exp alfie $';
$help = <<'EOF';
WWWSync:
    Compares the directory structure locally with that currently stored
    on the ftp server.  Any files and directories that no longer exist
    locally are removed, then any new or updated directories and files
    are created.
options:
    -H      : display this help message and exit
    -V      : display the version and exit
    -n      : just display the actions that would be taken, not perform them
    -v      : be more verbose in reporting
    -q      : operate quietly
    -f file : read settings from configuration file
    -l dir  : local directory for WWW pages
    -r dir  : remote directory for WWW pages
    -h host : ftp host to connect to
    -u user : user to login
    -p pass : password
EOF
#    -L      : convert filenames to lower case

use Getopt::Std;
use Net::FTP;
use Time::Local;
use POSIX strstr;

# ---------------------------------------------------------------------------
# User Serviceable Parts.  Either edit to taste, use a config file with
# -f, or specify the individual arguments using the command line.

# ftp machine to upload to
$ftphost  = "";
$user     = "";
$password = "";

# local directory containing WWW pages
$loc_dir = "";
$rem_dir = "";

# Files to ignore on the local and remote machines respectively
@rem_ignore = ( );
@loc_ignore = ( );

# Files to upload as text (ASCII).
@text = ( '*.htm', '*.html', '*.txt', '*.map' );

# ---------------------------------------------------------------------------
# Argument handling.  The settings above can be overridden using the
# parameters specified in an external config file (-f), which can be
# in turn overridden by the particular command line arguments.

$0 =~ s%.*/%%;
$0 =~ s%\.pl$%%;

die "usage: $0 [-n] [-v] [-q] [-f config] [-h ftphost] [-u user] [-p password] [-l loc_dir] [-r rem_dir]\n"
  . "   or: $0 -H (to display more information)\n"
  . "   or: $0 -V\n"
    unless getopts( 'nvqf:h:u:p:l:r:HVD' ) && @ARGV == 0;

die $help               if $opt_H;
die "WWWSync: $RCSid\n" if $opt_V;

# ---------------------------------------------------------------------------
if ( $opt_f )
{
    die "$0: can't read config file \"$opt_f\"\n" unless -r $opt_f;
    local( @INC ) = ( '.' );
    eval 'do $opt_f';
    die $@ if $@;
}

$loc_dir  = $opt_l if $opt_l;
$rem_dir  = $opt_r if $opt_r;
$ftphost  = $opt_h if $opt_h;
$user     = $opt_u if $opt_u;
$password = $opt_p if $opt_p;

die "$0: no local directory specified for WWW pages\n"
    unless $loc_dir ne "";
die "$0: $loc_dir is not a directory\n"
    unless -d $loc_dir;
die "$0: no remote ftp host specified\n"
    if $ftphost eq "";
die "$0: must specify password as well as user name\n"
    if $user ne "" && $password eq "";
die "$0: must specify user name as well as password\n"
    if $user eq "" && $password ne "";

( $loc_ignore = &glob2re( @loc_ignore ) )
    || die "$0: invalid value in \@loc_ignore\n";

( $rem_ignore = &glob2re( @rem_ignore ) )
    || die "$0: invalid value in \@rem_ignore\n";

( $text = &glob2re( @text ) )
    || die "$0: invalid value in \@text\n";

# ---------------------------------------------------------------------------
print "Scanning local directory... \n" unless $opt_q;

@dir = ( $loc_dir );
while ( @dir )
{
    $dir = pop @dir;
    opendir( DIR, $dir ) 
	|| die "$0: can't read directory \"$dir\": $!\n";
    while ( $file = readdir( DIR ) )
    {
	next if $file =~ /^\.\.?$/;		# Skip "." and ".."

	$path = substr( $dir, length( $loc_dir )  ) . "/$file";

	if ( -d "$dir/$file" )
	{
	    next if "$path/" =~ m/$loc_ignore/o;
	    next if "$path/" =~ m/$rem_ignore/o;

	    push( @dir, "$dir/$file" );

	    $path =~ tr/A-Z/a-z/ if $opt_L;
	    push( @loc_path, $path );
	    $loc_type{ $path } = "d";
	    print "--- -- --:-- $path\n" if $opt_v;
	}
	elsif ( -f _ )
	{
	    next if $path =~ m/$loc_ignore/o;
	    next if $path =~ m/$rem_ignore/o;

	    push( @loc_path, $path );
	    $loc_type{ $path } = "f";
	    $loc_time{ $path } = ( stat( _ ) )[9];
	    print &time2ls( $loc_time{ $path } ), " $path\n"
		if $opt_v;
	}
	else
	{
	    warn "ignoring \"$path\": not a file or directory\n";
	}
    }
    closedir DIR;
}

# ---------------------------------------------------------------------------
print "Connecting to ftp server... \n" unless $opt_q;

$ftp = Net::FTP->new( $ftphost );

$ftp->debug( 1 ) if $opt_D;

if ( $user ne "" )
{
    $ftp->login( $user, $password )
	|| die "$0: login failed: \"", $ftp->message, "\"\n";
}
else
{
    $ftp->login()
	|| die "$0: login failed: \"", $ftp->message, "\"\n";
}

$ftp->cwd( $rem_dir )
    || die "$0: $rem_dir: unable to change directory: \"", $ftp->message, "\"\n"
	if $rem_dir ne "";

( $base = $ftp->pwd() )
    || die "$0: can't find current directory: \"", $ftp->message, "\"\n";

# ---------------------------------------------------------------------------
print "Scanning remote directory... \n" unless $opt_q;

@list = $ftp->ls( '-lRa' );

if ( @list == 0 )
{
    die "Please Report!!!: nothing returned by 'ls -lRa'\n",
	"FTP message: ", $ftp->message, "\n";
}

$dir = "";
for $_ ( @list )
{
    if ( /^-([r-][w-][x-]){3}\s+/ )
    {
	chomp;
	@x = split( ' ', $_, 9 );

	$path = "$dir/$x[8]";

	next if $path =~ m/$rem_ignore/o;

	push( @rem_path, $path );
	$rem_time{ $path } = &ls2time( $x[5], $x[6], $x[7] );
	$rem_type{ $path } = "f";

	print &time2ls( $rem_time{ $path } ), " $path\n" if $opt_v;
    }
    elsif ( /^d([r-][w-][x-]){3}\s+/ || /^$/ || /^total \d+$/ )
    {
	next;
    }
    elsif ( /^(.*):$/ )
    {
	$dir = $1;
	$dir =~ s|^\.||;

	if ( "$dir/" !~ m/$rem_ignore/o )
	{
	    push( @rem_path, $dir );
	    $rem_type{ $dir } = "d";
	    print "--- -- --:-- $dir\n" if $opt_v;
	}
    }
    else
    {
	warn "Please Report!!!:\nBogus: $_";
    }
}

# ---------------------------------------------------------------------------
print "Updating remote directory...\n" unless $opt_q;

# Scan remote list, deleting files and directories that should no longer exist
for $path ( reverse @rem_path )
{
    if ( $rem_type{ $path } ne $loc_type{ $path } )
    {
	if ( $rem_type{ $path } eq "d" )
	{
	    print "rmdir  $path\n" unless $opt_q;
	    $ftp->RMD( $base.$path ) 
		|| die "$0: $path: rmdir failed: \"", $ftp->message, "\"\n"
		    unless $opt_n;
	}
	else
	{
	    print "delete $path\n" unless $opt_q;
	    $ftp->DELE( $base.$path )
		|| die "$0: $path: delete failed: \"", $ftp->message, "\"\n"
		    unless $opt_n;
	}
    }
}

# Scan local list, making directories that are don't exist on the ftp
# server, and uploading files that are either new or changed.
for $path ( @loc_path )
{
    if ( $loc_type{ $path } eq "d" )
    {
	if ( $rem_type{ $path } ne "d" )
	{
	    print "mkdir  $path\n" unless $opt_q;
	    $ftp->MKD( $base.$path )
		|| die "$0: $path: mkdir failed: \"", $ftp->message, "\"\n"
		    unless $opt_n;
	}
    }
    else
    {
	if ( $loc_time{ $path } > $rem_time{ $path } )
	{
	    print "upload $path\n" unless $opt_q;
	    if ( $path =~ m/$text/o )
	    {
		$ftp->ascii()
		    || die "$0: mode ascii: \"", $ftp->message, "\"\n";
	    }
	    else
	    {
		$ftp->binary()
		    || die "$0: mode binary: \"", $ftp->message, "\"\n";
	    }
	    $ftp->put( $loc_dir.$path, $base.$path."-in" )
		|| die "$0: $path: put failed: \"", $ftp->message, "\"\n"
		    unless $opt_n;
	    $ftp->rename( $base.$path."-in", $base.$path ) 
		|| die "$0: $path: rename failed: \"", $ftp->message, "\"\n"
		    unless $opt_n;
	}
	else
	{
	    print "leave  $path\n" if $opt_v;
	}
    }
}

# ---------------------------------------------------------------------------
print "Done.\n" unless $opt_q;

$ftp->quit()
    || warn "$0: quit returned: \"", $ftp->message, "\"\n";

# ---------------------------------------------------------------------------

#   Given the fields from the output of 'ls -l', either of the form of
# "Jul 31 12:32" or "Jul 31 1996", return the time as the number of
# seconds since the epoch.  Times are in GMT.
#   If the time is given "12:32", then the nearest year for the month is
# chosen.  If a year is given, then the time is assumed to be "23:59"
# (this is so that when remote files become > 3 months old, they are not
# suddenly uploaded again).
sub ls2time
{
    local( $month, $date, $timeoryear ) = @_; local( $yr, $mo, $hr, $mn );

    $mo = strstr( "JanFebMarAprMayJunJulAugSepOctNovDec", $month ) / 3;

    if ( $timeoryear =~ /^(\d+):(\d+)$/ )
    {
	$hr = $1; $mn = $2;
	local($year, $month) = ( gmtime( time ) )[ 5, 4 ];
	$yr = $year;
	if ( $mo > $month && $mo - $month > 6 )
	{
	    $yr--;
	}
	elsif ( $month > $mo && $month - $mo > 6 )
	{
	    $yr++;
	}
    }
    else
    {
	$hr = 23; $mn = 59;
	$yr = $timeoryear - 1900;
    }

    timegm(59,$mn,$hr,$date,$mo,$yr);
}

#   Convert a time given as seconds since the epoch into a short form
# as used in 'ls -l'.  Eg "Jan  1 12:43", or "Aug  1  1996" (for dates
# greater than 3 months ago, or more than 1 month into the future).
sub time2ls
{
    local( $time ) = @_;
    local( $s ) = scalar gmtime( $time );

    if ( $^T - $time < 90 * 24 * 60 * 60
	&& $time - $^T < 30 * 24 * 60 * 60 )
    {
	substr( $s, 4, 12 );
    }
    else
    {
	substr( $s, 4, 7 ).substr( $s, 19, 5 );
    }
}

#   Convert an array of shell-style glob patterns into a regular expression
# Returns undef if the resultant regular expression is not valid.
sub glob2re
{
    local( @pattern ) = @_;
    local( $pattern );

    # Convert elements of glob to regular expression
    for $pattern ( @pattern )
    {
	$pattern =~ s/\./\\./g;
	$pattern =~ s/\+/\\+/g;
	$pattern =~ s/\*/.*/g;
	$pattern =~ s/\?/./g;
    }

    # Join to form single regular expression
    $pattern = '^(' . join( '|', @pattern ) . ')$';

    eval '/$pattern/';			# Test R.E.

    $@ ? undef : $pattern;
}
