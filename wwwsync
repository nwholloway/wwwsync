#! /usr/bin/perl
# WWWSync: Upload new modifications to your WWW pages by ftp.
# Author : Nick Holloway 
#  Email : Nick.Holloway@alfie.demon.co.uk
#    WWW : http://www.alfie.demon.co.uk/

$RCSid = '$Id: wwwsync,v 1.10 1999/12/06 19:55:30 alfie Exp alfie $';
$help = <<'EOF';
WWWSync:
    Compares the directory structure locally with that currently stored
    on the ftp server.  Any files and directories that no longer exist
    locally are removed, then any new or updated directories and files
    are created.
options:
    -H      : display this help message and exit
    -V      : display the version and exit
    -n      : just display the actions that would be taken, not perform them
    -v      : be more verbose in reporting
    -q      : operate quietly
    -P      : use passive transfers
    -f file : read settings from configuration file
    -l dir  : local directory for WWW pages
    -r dir  : remote directory for WWW pages
    -h host : ftp host to connect to (use host:port for non-standard port)
    -u user : user to login
    -p pass : password
    -R      : recurse to list each directory seperately
    -T      : calculate time difference (also allows for non-GMT timestamps)
EOF
#    -L      : convert filenames to lower case

use Getopt::Std;
use Net::FTP;
use Time::Local;

# ---------------------------------------------------------------------------
# User Serviceable Parts.  Either edit to taste, use a config file with
# -f, or specify the individual arguments using the command line.

# ftp machine to upload to
$ftphost  = "";
$user     = "";
$password = "";

# use passive FTP connections
$passive  = 0;

# resurse to list each directory seperately
$recurse  = 0;

# calculate time difference between local and remote machine
$timewarp = 0;

# local directory containing WWW pages
$loc_dir = "";
$rem_dir = "";

# Files to ignore on the local and remote machines respectively
@rem_ignore = ( );
@loc_ignore = ( );

# Files to upload as text (ASCII).
@text = ( '*.htm', '*.html', '*.txt', '*.map' );

# ---------------------------------------------------------------------------
# Argument handling.  The settings above can be overridden using the
# parameters specified in an external config file (-f), which can be
# in turn overridden by the particular command line arguments.

$0 =~ s%.*/%%;
$0 =~ s%\.pl$%%;

die "usage: $0 [-n] [-v] [-q] [-f config]\n"
  . "   or: $0 [-n] [-v] [-q] [-P] [-R] [-h ftphost] [-u user] [-p password]\n"
  . "                    [-l loc_dir] [-r rem_dir]\n"
  . "   or: $0 -H (to display more information)\n"
  . "   or: $0 -V (to display version)\n"
    unless getopts( 'nvqf:h:u:p:l:r:HVDPRT' ) && @ARGV == 0;

die $help               if $opt_H;
die "WWWSync: $RCSid\n" if $opt_V;

# ---------------------------------------------------------------------------
if ( $opt_f )
{
    die "$0: can't read config file \"$opt_f\"\n" unless -r $opt_f;
    local( @INC ) = ( '.' );
    do $opt_f;
    die "$0: error loading config file:\n$@" if $@;
}

$loc_dir  = $opt_l if $opt_l;
$rem_dir  = $opt_r if $opt_r;
$ftphost  = $opt_h if $opt_h;
$ftpport  = ( $ftphost =~ s/:(\d+)$// ) ? $1 : 21;
$user     = $opt_u if $opt_u;
$password = $opt_p if $opt_p;
$passive  = 1      if $opt_P;
$recurse  = 1      if $opt_R;
$timewarp = 1      if $opt_T;

$| = 1 if $opt_D;

die "$0: no local directory specified for WWW pages\n"
    unless $loc_dir ne "";
die "$0: $loc_dir is not a directory\n"
    unless -d $loc_dir;
die "$0: no remote ftp host specified\n"
    if $ftphost eq "";
die "$0: must specify password as well as user name\n"
    if $user ne "" && $password eq "";
die "$0: must specify user name as well as password\n"
    if $user eq "" && $password ne "";

( $loc_ignore = &glob2re( @loc_ignore ) )
    || die "$0: invalid value in \@loc_ignore\n";

( $rem_ignore = &glob2re( @rem_ignore ) )
    || die "$0: invalid value in \@rem_ignore\n";

( $text = &glob2re( @text ) )
    || die "$0: invalid value in \@text\n";

# ---------------------------------------------------------------------------
print "Scanning local directory... \n" unless $opt_q;

@dir = ( $loc_dir );
while ( @dir )
{
    $dir = pop @dir;
    opendir( DIR, $dir ) 
	|| die "$0: can't read directory \"$dir\": $!\n";
    while ( defined( $file = readdir( DIR ) ) )
    {
	next if $file =~ /^\.\.?$/;		# Skip "." and ".."

	$path = substr( $dir, length( $loc_dir )  ) . "/$file";

	if ( -d "$dir/$file" )
	{
	    next if "$path/" =~ m/$loc_ignore/o;
	    next if "$path/" =~ m/$rem_ignore/o;

	    push( @dir, "$dir/$file" );

	    $path =~ tr/A-Z/a-z/ if $opt_L;
	    push( @loc_path, $path );
	    $loc_type{ $path } = "d";
	    print "--- -- --:-- $path\n" if $opt_v;
	}
	elsif ( -f _ )
	{
	    next if $path =~ m/$loc_ignore/o;
	    next if $path =~ m/$rem_ignore/o;

	    push( @loc_path, $path );
	    $loc_type{ $path } = "f";
	    $loc_time{ $path } = ( stat( _ ) )[9];
	    print &time2ls( $loc_time{ $path } ), " $path\n"
		if $opt_v;
	}
	else
	{
	    warn "ignoring \"$path\": not a file or directory\n";
	}
    }
    closedir DIR;
}

# ---------------------------------------------------------------------------
print "Connecting to ftp server... \n" unless $opt_q;

$ftp = Net::FTP->new( $ftphost, Port => $ftpport, Debug => $opt_D, Passive => $passive );

die "$0: $ftphost ($ftpport): unable to connect\n"
    unless defined( $ftp );

if ( $user ne "" )
{
    $ftp->login( $user, $password )
	|| die "$0: login failed: \"", &nonl( $ftp->message ), "\"\n";
}
else
{
    $ftp->login()
	|| die "$0: login failed: \"", &nonl( $ftp->message ), "\"\n";
}

$ftp->cwd( $rem_dir )
    || die "$0: $rem_dir: unable to change directory: \"", &nonl( $ftp->message ), "\"\n"
	if $rem_dir ne "";

( $base = $ftp->pwd() )
    || die "$0: can't find current directory: \"", &nonl( $ftp->message ), "\"\n";

# ---------------------------------------------------------------------------
print "Scanning remote directory... \n" unless $opt_q;

if ( $timewarp )
{
    $timewarp = time;
    $tstamp = $ftp->put_unique( "/dev/null", "tstamp" );
    if ( $tstamp )
    {
	$tstamp = "/$tstamp";
    }
    else
    {
	# Pick a name that shouldn't clash
	for ( '.' , '$', '_', '%', '~', '42' )
	{
	    $path = "/${_}tstamp";
	    if ( $path !~ m/$rem_ignore/o && ! $loc_type{ $path } )
	    {
		$tstamp = $path;
		$ftp->put( "/dev/null", $base.$tstamp )
		    || die "$0: $path: unable to create timestamp file: \"", 
							&nonl( $ftp->message ), "\"\n";
		last;
	    }
	}
	if ( ! $tstamp )
	{
	    die "$0: unable to create unique timestamp file\n";
	}
    }
}

@dirs = ( "" );
while ( @dirs ) 
{
    $dir = pop @dirs;

    # Change to subdirectory (required if recursing each directory)
    $ftp->cwd( "$base$dir" )
	|| die "$0: $dir: unable to change directory: \"", &nonl( $ftp->message ), "\"\n"
	    if $dir ne "";

    @list = $recurse ? $ftp->dir() : $ftp->ls( '-lRa' );

    if ( @list == 0 )
    {
	die "Please Report!!!: nothing for directory listing\n",
	    "FTP message: ", &nonl( $ftp->message ), "\n";
    }

    for $_ ( @list )
    {
	chomp;
	print STDERR "<<< $_\n" if $opt_D;
	if ( /^-([r-][w-][sStTx-]){3}\s+/ )
	{
	    @x = split( ' ', $_, 9 );

	    $path = "$dir/$x[8]";

	    next if $path =~ m/$rem_ignore/o;

	    push( @rem_path, $path )
		unless $timewarp && $path eq $tstamp;
	    $rem_time{ $path } = &ls2time( $x[5], $x[6], $x[7] );
	    $rem_type{ $path } = "f";

	    print &time2ls( $rem_time{ $path } ), " $path\n" if $opt_v;
	}
	elsif ( /^d([r-][w-][sStTx-]){3}\s+/ )
	{
	    next if ! $recurse;

	    @x = split( ' ', $_, 9 );

	    next if $x[8] =~ /^\.\.?$/;

	    $subdir = "$dir/$x[8]";

	    if ( "$subdir/" !~ m/$rem_ignore/o )
	    {
		push( @dirs, $subdir );
		push( @rem_path, $subdir );
		$rem_type{ $subdir } = "d";
		print "--- -- --:-- $subdir\n" if $opt_v;
	    }
	}
	elsif ( /^$/ || /^total \d+$/ )
	{
	    next;
	}
	elsif ( /^[cblps]([r-][w-][sStTx-]){3}\s+/ )
	{
	    @x = split( ' ', $_, 9 );
	    $path = "$dir/$x[8]";

	    print "Ignoring $x[8]\n" if $opt_v;
	    if ( ! defined( $loc_type{ $path } ) )
	    {
		warn "ignoring \"$path\": not a file or directory\n";
	    }
	    else
	    {
		die "$0: \"$path\": exists locally,"
			    . " and is not a file or directory remotely\n";
	    }
	}
	elsif ( /^(.*):$/ )
	{
	    warn "Please Report!!!:\n*** Bogus: $_" if $recurse;

	    $dir = "/$1";
	    $dir =~ s|^/\./|/|;	# some FTP daemons report "./directory:"

	    if ( $dir eq "/." )	# some FTP daemons start listing with ".:"
	    {
		$dir = "";
		next;
	    }

	    if ( "$dir/" !~ m/$rem_ignore/o )
	    {
		push( @rem_path, $dir );
		$rem_type{ $dir } = "d";
		print "--- -- --:-- $dir\n" if $opt_v;
	    }
	}
	else
	{
	    if ( ! $recurse && @rem_path == 0 )
	    {
		die "$0: try using '-R' flag or setting '$recurse = 1'\n";
	    }
	    warn "Please Report!!!:\n*** Bogus: $_";
	}
    }
}

if ( $timewarp )
{
    $ftp->delete( $base.$tstamp )
	|| die "$0: $tstamp: delete failed: \"", &nonl( $ftp->message ), "\"\n";
    print "Local : ", &time2ls( $timewarp ), "\n" if $opt_D;
    print "Remote: ", &time2ls( $rem_time{ $tstamp } ), "\n" if $opt_D;
    $timewarp = $rem_time{ $tstamp } - $timewarp;
    $timewarp -= $timewarp % 60;
    print "Time difference is ", $timewarp, " seconds\n" if $opt_v;
}

# ---------------------------------------------------------------------------
print "Updating remote directory...\n" unless $opt_q;

# Scan remote list, deleting files and directories that should no longer exist
for $path ( reverse sort @rem_path )
{
    if ( $rem_type{ $path } ne $loc_type{ $path } )
    {
	if ( $rem_type{ $path } eq "d" )
	{
	    print "rmdir  $path\n" unless $opt_q;
	    $ftp->rmdir( $base.$path ) || $ftp->status == Net::FTP::CMD_OK
		|| die "$0: $path: rmdir failed: \"", &nonl( $ftp->message ), "\"\n"
		    unless $opt_n;
	}
	else
	{
	    print "delete $path\n" unless $opt_q;
	    $ftp->delete( $base.$path )
		|| die "$0: $path: delete failed: \"", &nonl( $ftp->message ), "\"\n"
		    unless $opt_n;
	}
    }
}

# Scan local list, making directories that are don't exist on the ftp
# server, and uploading files that are either new or changed.
for $path ( sort @loc_path )
{
    if ( $loc_type{ $path } eq "d" )
    {
	if ( $rem_type{ $path } ne "d" )
	{
	    print "mkdir  $path\n" unless $opt_q;
	    $ftp->mkdir( $base.$path )
		# Ignore error for now, as only more recent versions of
		# Net::FTP deal with servers that fail to follow RFC959.
		# || die "$0: $path: mkdir failed: \"", &nonl( $ftp->message ), "\"\n"
		    unless $opt_n;
	}
    }
    else
    {
	if ( $loc_time{ $path } + $timewarp > $rem_time{ $path } )
	{
	    print "upload $path\n" unless $opt_q;
	    if ( $path =~ m/$text/o )
	    {
		$ftp->ascii()
		    || die "$0: mode ascii: \"", &nonl( $ftp->message ), "\"\n"
			unless $opt_n;
	    }
	    else
	    {
		$ftp->binary()
		    || die "$0: mode binary: \"", &nonl( $ftp->message ), "\"\n"
			unless $opt_n;
	    }
	    $ftp->put( $loc_dir.$path, $base.$path."-in" )
		|| die "$0: $path: put failed: \"", &nonl( $ftp->message ), "\"\n"
		    unless $opt_n;
	    $ftp->rename( $base.$path."-in", $base.$path ) 
		|| die "$0: $path: rename failed: \"", &nonl( $ftp->message ), "\"\n"
		    unless $opt_n;
	}
	else
	{
	    print "leave  $path\n" if $opt_v;
	}
    }
}

# ---------------------------------------------------------------------------
print "Done.\n" unless $opt_q;

$ftp->quit()
    || warn "$0: quit returned: \"", &nonl( $ftp->message ), "\"\n";

# ---------------------------------------------------------------------------

#   Given the fields from the output of 'ls -l', either of the form of
# "Jul 31 12:32" or "Jul 31 1996", return the time as the number of
# seconds since the epoch.  Times are in GMT.
#   If the time is given "12:32", then the nearest year for the month is
# chosen.  If a year is given, then the time is assumed to be "23:59"
# (this is so that when remote files become > 3 months old, they are not
# suddenly uploaded again).
sub ls2time
{
    local( $month, $date, $timeoryear ) = @_;
    local( $yr, $mo, $hr, $mn );
    local( %month ) = ( 'Jan', 1, 'Feb', 2, 'Mar', 3, 'Apr', 4,
			'May', 5, 'Jun', 6, 'Jul', 7, 'Aug', 8,
			'Sep', 9, 'Oct', 10, 'Nov', 11, 'Dec', 12 );

    $mo = $month{ $month } -1;

    if ( $timeoryear =~ /^(\d+):(\d+)$/ )
    {
	$hr = $1; $mn = $2;
	local($year, $month) = ( gmtime( time ) )[ 5, 4 ];
	$yr = $year;
	if ( $mo > $month && $mo - $month > 6 )
	{
	    $yr--;
	}
	elsif ( $month > $mo && $month - $mo > 6 )
	{
	    $yr++;
	}
    }
    else
    {
	$hr = 23; $mn = 59;
	$yr = $timeoryear - 1900;
    }

    timegm(59,$mn,$hr,$date,$mo,$yr);
}

#   Convert a time given as seconds since the epoch into a short form
# as used in 'ls -l'.  Eg "Jan  1 12:43", or "Aug  1  1996" (for dates
# greater than 3 months ago, or more than 1 month into the future).
sub time2ls
{
    local( $time ) = @_;
    local( $s ) = scalar gmtime( $time );

    if ( $^T - $time < 90 * 24 * 60 * 60
	&& $time - $^T < 30 * 24 * 60 * 60 )
    {
	substr( $s, 4, 12 );
    }
    else
    {
	substr( $s, 4, 7 ).substr( $s, 19, 5 );
    }
}

#   Convert an array of shell-style glob patterns into a regular expression
# Returns undef if the resultant regular expression is not valid.
sub glob2re
{
    local( @pattern ) = @_;
    local( $pattern );

    # Convert elements of glob to regular expression
    for $pattern ( @pattern )
    {
	$pattern =~ s/\./\\./g;
	$pattern =~ s/\+/\\+/g;
	$pattern =~ s/\*/.*/g;
	$pattern =~ s/\?/./g;
    }

    # Join to form single regular expression
    $pattern = '^(' . join( '|', @pattern ) . ')$';

    eval '/$pattern/';			# Test R.E.

    $@ ? undef : $pattern;
}

#   Remove newline from end of text, and return text.
sub nonl
{
    local( $text ) = @_;

    chomp( $text );

    return $text;
}
